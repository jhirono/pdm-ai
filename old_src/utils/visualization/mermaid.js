/**
 * Mermaid diagram generator for PDM visualizations
 * Converts JTBD and scenario data into Mermaid markdown syntax
 */

/**
 * Generate a Mermaid diagram from input data
 * @param {Object} data - Input data with JTBDs and scenarios
 * @param {Object} options - Visualization options
 * @returns {Object} Result object with diagram content and statistics
 */
function generateMermaidDiagram(data, options) {
  // Track stats for the generated diagram
  const stats = {
    nodeCount: 0,
    edgeCount: 0
  };

  let mermaidContent = '';

  // Select the appropriate view type
  switch (options.view) {
    case 'jtbd':
      mermaidContent = generateJtbdCentricView(data, options, stats);
      break;
    case 'persona':
      // For Phase 1, we'll add a placeholder for future implementations
      mermaidContent = generatePlaceholderDiagram('Persona-centric view will be implemented in Phase 3');
      break;
    case 'priority':
      // For Phase 1, we'll add a placeholder for future implementations
      mermaidContent = generatePlaceholderDiagram('Priority heat map will be implemented in Phase 3');
      break;
    case 'source':
      // For Phase 1, we'll add a placeholder for future implementations
      mermaidContent = generatePlaceholderDiagram('Source attribution view will be implemented in Phase 3');
      break;
    default:
      mermaidContent = generateJtbdCentricView(data, options, stats);
  }

  return {
    content: mermaidContent,
    stats
  };
}

/**
 * Generate a JTBD-centric Mermaid diagram
 * @param {Object} data - Input data with JTBDs and scenarios
 * @param {Object} options - Visualization options
 * @param {Object} stats - Statistics object to update
 * @returns {string} Mermaid diagram content
 */
function generateJtbdCentricView(data, options, stats) {
  // Initialize Mermaid diagram
  let diagram = 'graph TD\n';
  diagram += '  %% JTBD-centric visualization\n';
  diagram += '  %% Generated by PDM tool\n\n';

  // Style definitions
  diagram += '  %% Node styles\n';
  diagram += '  classDef abstractJtbd fill:#f9f,stroke:#333,stroke-width:2px;\n';
  diagram += '  classDef concreteJtbd fill:#bbf,stroke:#333,stroke-width:1px;\n';
  diagram += '  classDef scenario fill:#afa,stroke:#333,stroke-width:1px;\n\n';

  // Extract the JTBDs and scenarios from the data
  const { jtbds, scenarios } = data;

  // Filter JTBDs based on options and remove empty entries
  let filteredJtbds = (jtbds || [])
    .filter(jtbd => jtbd && jtbd.id && typeof jtbd.id === 'string' && jtbd.statement);
  
  // Apply abstract-only filter if specified
  if (options.abstractOnly) {
    filteredJtbds = filteredJtbds.filter(jtbd => jtbd.isAbstract);
  }

  // Apply max nodes limit
  if (filteredJtbds.length > options.maxNodes) {
    // Prioritize abstract JTBDs when limiting
    const abstractJtbds = filteredJtbds.filter(jtbd => jtbd.isAbstract);
    const concreteJtbds = filteredJtbds.filter(jtbd => !jtbd.isAbstract);
    
    const remainingSlots = options.maxNodes - abstractJtbds.length;
    if (remainingSlots > 0) {
      // Sort by priority (descending)
      concreteJtbds.sort((a, b) => (b.priority || 0) - (a.priority || 0));
      filteredJtbds = [...abstractJtbds, ...concreteJtbds.slice(0, remainingSlots)];
    } else {
      filteredJtbds = abstractJtbds.slice(0, options.maxNodes);
    }
  }

  // Create maps for different entities
  const jtbdMap = {};
  const abstractJtbds = [];
  const concreteJtbds = [];
  
  // Separate abstract and concrete JTBDs
  filteredJtbds.forEach(jtbd => {
    jtbdMap[jtbd.id] = jtbd;
    if (jtbd.isAbstract) {
      abstractJtbds.push(jtbd);
    } else {
      concreteJtbds.push(jtbd);
    }
  });

  // Add nodes for Abstract JTBDs
  if (abstractJtbds.length > 0) {
    diagram += '  %% Abstract JTBD nodes\n';
    abstractJtbds.forEach(jtbd => {
      const safeId = makeIdSafe(jtbd.id);
      const label = escapeText(jtbd.statement || 'Unnamed Abstract JTBD');
      const priorityStr = jtbd.priority ? ` (P${jtbd.priority})` : '';
      diagram += `  ${safeId}["${label}${priorityStr}"]\n`;
      stats.nodeCount++;
    });
    diagram += '\n';
  }
  
  // Add nodes for Concrete JTBDs
  if (concreteJtbds.length > 0) {
    diagram += '  %% Concrete JTBD nodes\n';
    concreteJtbds.forEach(jtbd => {
      const safeId = makeIdSafe(jtbd.id);
      const label = escapeText(jtbd.statement || 'Unnamed JTBD');
      const priorityStr = jtbd.priority ? ` (P${jtbd.priority})` : '';
      diagram += `  ${safeId}["${label}${priorityStr}"]\n`;
      stats.nodeCount++;
    });
    diagram += '\n';
  }

  // Add class assignments for JTBDs
  diagram += '  %% JTBD styling\n';
  filteredJtbds.forEach(jtbd => {
    const safeId = makeIdSafe(jtbd.id);
    if (jtbd.isAbstract) {
      diagram += `  class ${safeId} abstractJtbd;\n`;
    } else {
      diagram += `  class ${safeId} concreteJtbd;\n`;
    }
  });
  diagram += '\n';

  // Add edges for top-down JTBD hierarchical relationships (abstract -> concrete)
  diagram += '  %% JTBD hierarchical relationships (top-down only)\n';
  concreteJtbds.forEach(jtbd => {
    if (jtbd.parentId && jtbdMap[jtbd.parentId] && jtbdMap[jtbd.parentId].isAbstract) {
      const parentId = makeIdSafe(jtbd.parentId);
      const childId = makeIdSafe(jtbd.id);
      diagram += `  ${parentId} --> ${childId}\n`;
      stats.edgeCount++;
    }
  });
  diagram += '\n';
  
  // Check if scenarios have required properties (id, statement)
  const hasValidScenarios = scenarios && Array.isArray(scenarios) && 
    scenarios.some(s => s && s.id && s.statement);
  
  // If we have valid scenarios data, proceed with scenario visualization
  let relevantScenarios = [];
  if (hasValidScenarios) {
    // Filter out scenarios without valid IDs and statements
    relevantScenarios = scenarios.filter(scenario => 
      scenario && scenario.id && typeof scenario.id === 'string' && scenario.statement);
    
    // Track which scenarios are connected to JTBDs for visualization purposes
    const connectedScenarios = new Set();
    
    // Build a relationship map from JTBDs to scenarios and vice versa
    const jtbdToScenarioMap = new Map();
    const scenarioToJtbdMap = new Map();
    
    // First, process JTBD -> scenario relationships
    concreteJtbds.forEach(jtbd => {
      if (jtbd.relatedScenarios && Array.isArray(jtbd.relatedScenarios)) {
        jtbd.relatedScenarios.forEach(scenarioId => {
          if (!jtbdToScenarioMap.has(jtbd.id)) {
            jtbdToScenarioMap.set(jtbd.id, new Set());
          }
          jtbdToScenarioMap.get(jtbd.id).add(scenarioId);
          connectedScenarios.add(scenarioId);
        });
      }
    });
    
    // Then, process scenario -> JTBD relationships
    relevantScenarios.forEach(scenario => {
      if (scenario.relatedJtbds && Array.isArray(scenario.relatedJtbds)) {
        scenario.relatedJtbds.forEach(jtbdId => {
          if (!scenarioToJtbdMap.has(scenario.id)) {
            scenarioToJtbdMap.set(scenario.id, new Set());
          }
          scenarioToJtbdMap.get(scenario.id).add(jtbdId);
          
          // Also add the reverse relationship if it doesn't exist
          if (jtbdMap[jtbdId] && !jtbdMap[jtbdId].isAbstract) {
            if (!jtbdToScenarioMap.has(jtbdId)) {
              jtbdToScenarioMap.set(jtbdId, new Set());
            }
            jtbdToScenarioMap.get(jtbdId).add(scenario.id);
            connectedScenarios.add(scenario.id);
          }
        });
      }
    });
    
    // Prioritize connected scenarios to keep in the visualization
    const prioritizedScenarios = [...relevantScenarios].sort((a, b) => {
      // First, prioritize connected scenarios
      const aConnected = connectedScenarios.has(a.id);
      const bConnected = connectedScenarios.has(b.id);
      
      if (aConnected !== bConnected) {
        return aConnected ? -1 : 1;
      }
      
      // Then by priority
      return (b.priority || 0) - (a.priority || 0);
    });
    
    // Apply max nodes limit for scenarios
    const remainingNodeSlots = options.maxNodes - stats.nodeCount;
    if (prioritizedScenarios.length > remainingNodeSlots) {
      relevantScenarios = prioritizedScenarios.slice(0, remainingNodeSlots);
    } else {
      relevantScenarios = prioritizedScenarios;
    }
    
    // Create a map of scenarios by ID
    const scenarioMap = {};
    relevantScenarios.forEach(scenario => {
      scenarioMap[scenario.id] = scenario;
    });
    
    // Add nodes for scenarios
    diagram += '  %% Scenario nodes\n';
    relevantScenarios.forEach(scenario => {
      const safeId = makeIdSafe(scenario.id);
      const label = formatScenarioLabel(scenario);
      diagram += `  ${safeId}["${label}"]\n`;
      stats.nodeCount++;
    });
    diagram += '\n';
    
    // Add class assignments for scenarios
    diagram += '  %% Scenario styling\n';
    relevantScenarios.forEach(scenario => {
      const safeId = makeIdSafe(scenario.id);
      diagram += `  class ${safeId} scenario;\n`;
    });
    diagram += '\n';
    
    // Add connections from concrete JTBDs to scenarios
    diagram += '  %% JTBD to Scenario relationships\n';
    
    // Use the relationship map to create connections
    jtbdToScenarioMap.forEach((scenarioIds, jtbdId) => {
      const jtbd = jtbdMap[jtbdId];
      if (jtbd && !jtbd.isAbstract) { // Only connect concrete JTBDs
        const jtbdIdSafe = makeIdSafe(jtbdId);
        scenarioIds.forEach(scenarioId => {
          if (scenarioMap[scenarioId]) { // Only connect if scenario is in the visualization
            const scenIdSafe = makeIdSafe(scenarioId);
            diagram += `  ${jtbdIdSafe} --> ${scenIdSafe}\n`;
            stats.edgeCount++;
          }
        });
      }
    });
  } else {
    // If no valid scenarios, add a note to the diagram
    if (scenarios && scenarios.length > 0) {
      diagram += '  %% Note about scenarios\n';
      diagram += '  scenarioNote["Scenarios were found in the data, but they lack required details (e.g., IDs or statements)"]\n';
      diagram += '  style scenarioNote fill:#ffffcc,stroke:#999,stroke-dasharray: 5 5\n\n';
    }
  }
  
  // Add a title and legend
  let legendItems = ['legend_abstract_jtbd["Abstract JTBD"]', 'legend_concrete_jtbd["Concrete JTBD"]'];
  let legendStyles = ['class legend_abstract_jtbd abstractJtbd;', 'class legend_concrete_jtbd concreteJtbd;'];
  
  // Only add scenario item to legend if we have valid scenarios
  if (hasValidScenarios) {
    legendItems.push('legend_scenario["Scenario"]');
    legendStyles.push('class legend_scenario scenario;');
  }
  
  diagram = 'graph TD\n' +
    '  %% JTBD-centric visualization (Hierarchical)\n' +
    '  %% Generated by PDM tool\n\n' +
    '  %% Title and Legend\n' +
    '  subgraph Legend\n' +
    '    ' + legendItems.join('\n    ') + '\n' +
    '  end\n\n' +
    '  ' + legendStyles.join('\n  ') + '\n\n' +
    diagram.substring(diagram.indexOf('  %% Node styles'));
  
  return diagram;
}

/**
 * Format a scenario label with persona, action, and value details
 * @param {Object} scenario - The scenario object
 * @returns {string} Formatted label
 */
function formatScenarioLabel(scenario) {
  if (!scenario) return 'Unnamed Scenario';
  
  // Check if this is a simple scenario with just a statement
  if (scenario.statement && (!scenario.persona && !scenario.action && !scenario.value)) {
    return escapeText(scenario.statement);
  }
  
  // Ensure required fields exist
  const persona = scenario.persona ? `<b>${escapeText(scenario.persona)}</b>` : '<i>User</i>';
  const action = scenario.action ? escapeText(scenario.action) : '';
  const value = scenario.value ? escapeText(scenario.value) : '';
  const priorityStr = scenario.priority ? ` (P${scenario.priority})` : '';
  
  // Format as: Persona: action → value (Pn)
  let label = `${persona}:<br/>${action}`;
  if (value) {
    label += `<br/>→ ${value}`;
  }
  label += priorityStr;
  
  return label;
}

/**
 * Generate a placeholder diagram for views not yet implemented
 * @param {string} message - Message to display in the diagram
 * @returns {string} Mermaid diagram content
 */
function generatePlaceholderDiagram(message) {
  return `graph TD
    %% Placeholder diagram
    A["${message}"]
    style A fill:#f9f,stroke:#333,stroke-width:2px
  `;
}

/**
 * Make an ID safe for use in Mermaid diagrams
 * @param {string} id - The original ID
 * @returns {string} Safe ID for Mermaid
 */
function makeIdSafe(id) {
  // Replace characters that might cause issues in Mermaid syntax
  return id.replace(/[^a-zA-Z0-9]/g, '_');
}

/**
 * Escape special characters in text for Mermaid diagrams
 * @param {string} text - The text to escape
 * @returns {string} Escaped text
 */
function escapeText(text) {
  if (!text) return '';
  // Replace characters that might cause issues in Mermaid syntax
  return text.replace(/"/g, '\\"').replace(/\n/g, ' ');
}

/**
 * Truncate text to a maximum length
 * @param {string} text - The text to truncate
 * @param {number} maxLength - Maximum length
 * @returns {string} Truncated text
 */
function truncateText(text, maxLength) {
  if (!text) return '';
  if (text.length <= maxLength) {
    return text;
  }
  return text.substring(0, maxLength) + '...';
}

module.exports = {
  generateMermaidDiagram
};